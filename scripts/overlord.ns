import { threadsToHackUntilPercent, threadsToRefillServer, threadsToMinSecurity, performHack} from "/util/util.ns";
import { formatMoney } from "/util/format.ns";
import { allServers } from "./survey.ns";

/** Attempt to execute a given script & threadcount across the provided array of servers
 * @param {NS} ns
 * @param {Array.<string>} botnetArr
 * @param {string} target
 * @param {string} script Name of the script that should be dispatched
 * @param {number} desiredThreads
 * @param {boolean} noisy Should the function print to the logs
 **/
function scriptRouter(ns, botnetArr, target, script, desiredThreads, noisy=false) {
	var scriptCost = ns.getScriptRam(script);
	var requestedThreads = desiredThreads;
	var createdPids = [];

	// if (noisy) {ns.print(ns.sprintf("%s:", script));}
	for (var serv of botnetArr) {
		var availableThreads = Math.floor((ns.getServerMaxRam(serv)-ns.getServerUsedRam(serv))/scriptCost);
		if (availableThreads < 1) continue; //Server is busy
		if (requestedThreads < 1) break; //Job is done

		var threadsToExec = 0;
		{
			if (availableThreads > requestedThreads) { threadsToExec = requestedThreads; requestedThreads = 0; }
			else { threadsToExec = availableThreads; requestedThreads -= availableThreads; }
		}

		if (threadsToExec != 0) {
			var pid = ns.exec(script, serv, threadsToExec, target);
			createdPids.push(pid);
			if (noisy && pid != 0) {ns.print(ns.sprintf("- %-18s x%-3d [%s]", script, threadsToExec, serv));}
		}
	}
	
	return { success: requestedThreads <= 0, pids: createdPids };
}

const leech     = "/util/leech.ns";
const crippler  = "/util/crippler.ns";
const flowerpot = "/util/flowerpot.ns";

/** @param {NS} ns **/
export async function main(ns) {
	ns.tail();
	ns.disableLog("ALL");
	var host = ns.getHostname();
	var target = ns.args[0];
	// ns.print(target);

	var lastPrinted = undefined;
	var noisy = true;
	var desiredPercentageToHack = 0.65;
	var additionalUpdateTime = 500;
	var cores = ns.getServer().cpuCores;

	var printTarget = () => {
		// ns.print(target);
		ns.print(ns.sprintf("[%s]->[%s] %s/%s (%.2f/%d)", ns.getHostname(), target,
			formatMoney(ns, ns.getServerMoneyAvailable(target)), formatMoney(ns, ns.getServerMaxMoney(target)),
			ns.getServerSecurityLevel(target), ns.getServerMinSecurityLevel(target)
		));
	}

	var runProg = (script, threads) => {
		ns.run(script, threads, target, threads);
		ns.print(ns.sprintf("- %-18s x%-3d [%s]", script, threads, ns.getHostname()));
	}

	var clampToMemoryConstraints = (script, desiredThreads) => {
		var possibleThreads = Math.floor((ns.getServerMaxRam(host)-ns.getServerUsedRam(host))/ns.getScriptRam(script));
		return Math.min(possibleThreads, desiredThreads);
	}

	while (true) {
		var wthreads = clampToMemoryConstraints(crippler, threadsToMinSecurity(ns, target, cores));
		var gthreads = clampToMemoryConstraints(flowerpot, threadsToRefillServer(ns, target, cores));

		if (wthreads > 0) {
			printTarget(target);
			runProg(crippler, wthreads);
			await ns.sleep(ns.getWeakenTime(target)+additionalUpdateTime);
		}

		if (gthreads > 0) {
			printTarget(target);
			runProg(flowerpot, gthreads);
			await ns.sleep(ns.getGrowTime(target)+additionalUpdateTime);
		}
		
		var hthreads = clampToMemoryConstraints(leech, threadsToHackUntilPercent(ns, target, desiredPercentageToHack));
		if (hthreads > 0) {
			printTarget(target);
			runProg(leech, hthreads);
			await ns.sleep(ns.getHackTime(target)+additionalUpdateTime);
		}

		await ns.sleep(100);
	}
}

/** @param {NS} ns **/
export async function main2(ns) {
	ns.tail();
	ns.disableLog("ALL");

	
	var target = ns.args[0];
	var botnet = (await allServers(ns)).filter(serv => (serv.requiredHackingSkill <= ns.getHackingLevel()) ).map(serv => serv.hostname);
	// ns.getServer().requiredHackingSkill

	var createdPids = [];
	
	// var lastHack = ns.getTimeSinceLastAug();
	var lastWeak = ns.getTimeSinceLastAug();
	// var lastGrow = ns.getTimeSinceLastAug();

	var lastPrinted = undefined;
	var noisy = true;
	var desiredPercentageToHack = 0.65;
	

	while (true) {
		var time = ns.getTimeSinceLastAug();

		if (threadsToMinSecurity(ns, target) > 10 /*&& time >= lastWeak*/) {
			var report = scriptRouter(ns, botnet, target, crippler, threadsToMinSecurity(ns, target), noisy);
			if (report.success) { //Able to dispatch all necessary weakening
				lastWeak = ns.getTimeSinceLastAug() + ns.getWeakenTime(target) + 1000;
			}
		}
		scriptRouter(ns, botnet, target, flowerpot, threadsToRefillServer(ns, target)+1, noisy);

		var moneyPercent = (ns.getServerMoneyAvailable(target) / ns.getServerMaxMoney(target))
		if (moneyPercent >= 0.95) {
			// await performHack(ns, target, threadsToHackUntilPercent(ns, target, desiredPercentageToHack));
			var hthread = threadsToHackUntilPercent(ns, target, desiredPercentageToHack);
			ns.run(leech, hthread, target, hthread);
			ns.print(ns.sprintf("- %-18s x%-3d [%s]", leech, hthread, ns.getHostname()));
			await ns.sleep(ns.getHackTime(target));
		}
		// ns.tprint(remainingHackablePercentage);
		// scriptRouter(ns, botnet, target, leech, threadsToHackUntilPercent(ns, target, remainingHackablePercentage), noisy);

		var line = ns.sprintf("[%s]->[%s] %s/%s (%.2f/%d)", ns.getHostname(), target,
			formatMoney(ns, ns.getServerMoneyAvailable(target)), formatMoney(ns, ns.getServerMaxMoney(target)),
			ns.getServerSecurityLevel(target), ns.getServerMinSecurityLevel(target)
		);
		
		if (lastPrinted != line) {
			lastPrinted = line;
			ns.print(lastPrinted);
		}
		await ns.sleep(1050);
	}
}